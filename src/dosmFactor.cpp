#include "dosmFactor.hpp"
#include "dosmLawVelocityVerlet.hpp"
#include "dosmLawLennardJonesPeriodic.hpp"
#include <cstdio>
#include <fstream>
#include <stdexcept>

#define DOSM_SEED        42
#define DOSM_SIGMA       1.0
#define DOSM_EPSILON     1.0
#define DOSM_BOX_LENGTH  50.0
#define DOSM_RAY_CUT     10.0
#define DOSM_MASS        1.0
#define DOSM_CHARGE      0.0
#define DOSM_DT          0.01
#define DOSM_STEPS       3

namespace dosm
{

	DosmFactor::DosmFactor(const str_t& file)
	{
		std::srand(DOSM_SEED);
		loadFile(file);
	}

	void DosmFactor::loadFile(const str_t& file)
	{
		std::ifstream in(file);
		if (!in)
		{
			DOSM_LOG_ERROR("Cannot open file: " + file);
			throw std::runtime_error("dosmFactor: cannot open file");
		}

		in.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

		vector_t<DosmParticle> particles;
		i32_t type;
		r64_t x, y, z;
		while (in >> type >> x >> y >> z)
		{
			DosmParticle particle(DOSM_MASS, DOSM_CHARGE);
			particle.position(0) = x;
			particle.position(1) = y;
			particle.position(2) = z;
			particle.velocity(0) = 0.1 * (r64_t(std::rand()) / RAND_MAX - 0.5);
			particle.velocity(1) = 0.1 * (r64_t(std::rand()) / RAND_MAX - 0.5);
			particle.velocity(2) = 0.1 * (r64_t(std::rand()) / RAND_MAX - 0.5);
			particles.push_back(particle);
		}

		DosmParticleSnap::Snap snap0;
		snap0.t = 0.0;
		snap0.particles = particles;

		dosmParticleSnap.snaps.clear();
		dosmParticleSnap.snaps.push_back(snap0);

		DOSM_LOG_INFO("Loaded " + std::to_string(particles.size()) + " particles");
	}

	void DosmFactor::outFile(void)
	{
		const str_t csvFile = "dosmdata.csv";
		const str_t pdbFile = "dosmvisual.pdb";

		std::ofstream csv(csvFile);
		if (!csv)
		{
			DOSM_LOG_ERROR("Cannot open CSV file: " + csvFile);
			return;
		}

		std::ofstream pdb(pdbFile);
		if (!pdb)
		{
			DOSM_LOG_ERROR("Cannot open PDB file: " + pdbFile);
			return;
		}

		chr_t line[256];

		snprintf(
				line,
				sizeof(line),
				"snap\tt\tid\tmass\tcharge\tx\ty\tz\tvx\tvy\tvz\tfx\tfy\tfz\tforce\tenergy\n"
				);
		csv << line;

		snprintf(line, sizeof(line), "HEADER    DOSM PARTICLES\n");
		pdb << line;

		snprintf(line, sizeof(line), "REMARK    Generated by dosmetric\n");
		pdb << line;

		snprintf(
				line,
				sizeof(line),
				"CRYST1%9.3f%9.3f%9.3f  90.00  90.00  90.00 P 1\n",
				DOSM_BOX_LENGTH, DOSM_BOX_LENGTH, DOSM_BOX_LENGTH
				);
		pdb << line;

		const idx_t nSnap = dosmParticleSnap.snaps.size();

		for (idx_t i = 0; i < nSnap; ++i)
		{
			const auto& snap = dosmParticleSnap.snaps[i];

			snprintf(
					line,
					sizeof(line),
					"MODEL     %d\n",
					i + 1
					);
			pdb << line;

			const idx_t n = snap.particles.size();
			for (idx_t j = 0; j < n; ++j)
			{
				const DosmParticle& particle = snap.particles[j];

				snprintf(
						line,
						sizeof(line),
						"%d\t%.6f\t%d\t%.3f\t%.3f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\n",
						i,
						snap.t,
						j,
						particle.mass,
						particle.charge,
						particle.position(0),
						particle.position(1),
						particle.position(2),
						particle.velocity(0),
						particle.velocity(1),
						particle.velocity(2),
						particle.force(0),
						particle.force(1),
						particle.force(2),
						particle.force.norm(),
						particle.energy
						);
				csv << line;

				snprintf(
						line,
						sizeof(line),
						"HETATM%5d  %-3.3s %-3.3s %4d    %8.3f%8.3f%8.3f%6.2f%6.2f           %.2s\n",
						j + 1,
						"X",
						"SIM",
						1,
						particle.position(0),
						particle.position(1),
						particle.position(2),
						1.00,
						0.00,
						"X"
						);

				pdb << line;
			}

			snprintf(line, sizeof(line), "ENDMDL\n");
			pdb << line;

			DOSM_PROGRESS("Generating output", i + 1, nSnap);
		}

		DOSM_LOG_INFO("Generated outputs: " + csvFile + ", " + pdbFile);
	}

	void DosmFactor::run(void)
	{
		DOSM_LOG_DEBUG("Factor::run() entered");

		IDosmLaw::Result result;
		DosmParticleSnap::Snap currSnap = dosmParticleSnap.snaps.back();

		for (auto& p : currSnap.particles)
			p.mass = DOSM_MASS;

		auto dosmLawLJP = std::make_unique<DosmLawLennardJonesPeriodic>(currSnap.particles, DOSM_SIGMA, DOSM_EPSILON, DOSM_BOX_LENGTH, DOSM_RAY_CUT);
		dosmParallel.init();

		for (idx_t step = 1; step < DOSM_STEPS; ++step)
		{
			idosmLaw = std::make_unique<DosmLawVelocityVerlet>(*dosmLawLJP, currSnap, DOSM_DT);
			dosmParallel.dispatch(1, [&](idx_t) { idosmLaw->kernel(&result); });

			dosmParticleSnap.snaps.push_back(currSnap);
			DOSM_PROGRESS("Time step", step + 1, DOSM_STEPS);
		}

		dosmParallel.release();
		outFile();

		DOSM_LOG_INFO("Factor::run() done");
	}

} // namespace dosm
