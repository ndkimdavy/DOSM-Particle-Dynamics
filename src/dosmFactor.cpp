#include "dosmFactor.hpp"
#include "dosmLawVelocityVerlet.hpp"
#include "dosmLawLennardJonesPeriodic.hpp"
#include <cstdio>
#include <fstream>
#include <stdexcept>

#define DOSM_SEED        42
#define DOSM_SIGMA       3.0
#define DOSM_EPSILON     0.2
#define DOSM_BOX_LENGTH  42.0
#define DOSM_RAY_CUT     10.0
#define DOSM_MASS        18.0
#define DOSM_CHARGE      0.0
#define DOSM_DT          1
#define DOSM_STEPS       3000

namespace dosm
{

	DosmFactor::DosmFactor(const str_t& file)
	{
		std::srand(DOSM_SEED);
		loadFile(file);
	}

	void DosmFactor::loadFile(const str_t& file)
	{
		std::ifstream in(file);
		if (!in)
		{
			DOSM_LOG_ERROR("Cannot open file: " + file);
			throw std::runtime_error("dosmFactor: cannot open file");
		}

		in.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

		vector_t<DosmParticle> particles;
		i32_t type;
		r64_t x, y, z;
		while (in >> type >> x >> y >> z)
		{
			DosmParticle particle(DOSM_MASS, DOSM_CHARGE);
			particle.position(0) = x;
			particle.position(1) = y;
			particle.position(2) = z;
			particle.velocity(0) = particle.velocity(1) = particle.velocity(2) = 0.0;
			particles.push_back(particle);
		}

		dosmParticleSnap.snaps.clear();
		dosmParticleSnap.snaps.push_back(DosmParticleSnap::Snap{0.0, particles});
		DOSM_LOG_INFO("Loaded " + std::to_string(particles.size()) + " particles");
	}

	void DosmFactor::outFile(void)
	{
		const str_t csvFile = "dosmdata.csv";
		const str_t pdbFile = "dosmvisual.pdb";

		std::ofstream csv(csvFile);
		if (!csv)
		{
			DOSM_LOG_ERROR("Cannot open CSV file: " + csvFile);
			return;
		}

		std::ofstream pdb(pdbFile);
		if (!pdb)
		{
			DOSM_LOG_ERROR("Cannot open PDB file: " + pdbFile);
			return;
		}

		chr_t line[256];

		snprintf(
				line,
				sizeof(line),
				"snap\tt\tid\tmass\tx\ty\tz\tpx\tpy\tpz\tfx\tfy\tfz\tEk\tEp\tT\n"
				);
		csv << line;


		snprintf(line, sizeof(line), "HEADER    DOSM PARTICLES\n");
		pdb << line;

		snprintf(line, sizeof(line), "REMARK    Generated by dosmetric\n");
		pdb << line;

		snprintf(
				line,
				sizeof(line),
				"CRYST1%9.3f%9.3f%9.3f  90.00  90.00  90.00 P 1\n",
				DOSM_BOX_LENGTH, DOSM_BOX_LENGTH, DOSM_BOX_LENGTH
				);
		pdb << line;

		const idx_t nSnap = dosmParticleSnap.snaps.size();

		for (idx_t i = 0; i < nSnap; ++i)
		{
			const auto& snap = dosmParticleSnap.snaps[i];
			const idx_t N = snap.particles.size();
			const idx_t Ndl = 3 * N - 3;
			constexpr r64_t CONSTANT_R = 0.00199;
			r64_t Ec = 0.0;
			for (const auto& particle : snap.particles)
				Ec += particle.k_energy;

			r64_t T = (Ndl > 0) ? (Ec / (Ndl * CONSTANT_R)) : 0.0;
			snprintf(
					line,
					sizeof(line),
					"MODEL     %d\n",
					i + 1
					);
			pdb << line;

			const idx_t n = snap.particles.size();
			for (idx_t j = 0; j < n; ++j)
			{
				const DosmParticle& particle = snap.particles[j];

				snprintf(
						line,
						sizeof(line),
						"%d\t%.6f\t%d\t%.3f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\t%.6f\n",
						i,
						snap.t,
						j,
						particle.mass,
						particle.position(0), particle.position(1), particle.position(2),
						particle.momentum(0), particle.momentum(1), particle.momentum(2),
						particle.force(0),    particle.force(1),    particle.force(2),
						particle.k_energy,
						particle.p_energy,
						T
						);
				csv << line;

				snprintf(
						line,
						sizeof(line),
						"HETATM%5d  %-3.3s %-3.3s %4d    %8.3f%8.3f%8.3f%6.2f%6.2f           %.2s\n",
						j + 1,
						"X",
						"SIM",
						1,
						particle.position(0), particle.position(1), particle.position(2),
						1.00,
						0.00,
						"X"
						);

				pdb << line;
			}

			snprintf(line, sizeof(line), "ENDMDL\n");
			pdb << line;

			DOSM_PROGRESS("Generating output", i + 1, nSnap, -1);
		}

		DOSM_LOG_INFO("Generated outputs: " + csvFile + ", " + pdbFile);
	}

	void DosmFactor::run(void)
	{
		DOSM_LOG_DEBUG("Factor::run() entered");

		IDosmLaw::Result result;
		DosmParticleSnap::Snap currSnap = dosmParticleSnap.snaps.back();

		for (auto& particle : currSnap.particles)
			particle.mass = DOSM_MASS;

		auto dosmLawLJ = std::make_unique<DosmLawLennardJones>(currSnap.particles, DOSM_SIGMA, DOSM_EPSILON);
		auto dosmLawLJP = std::make_unique<DosmLawLennardJonesPeriodic>(currSnap.particles, DOSM_SIGMA, DOSM_EPSILON, DOSM_BOX_LENGTH, DOSM_RAY_CUT);
		dosmParallel.init();
		idosmLaw = std::make_unique<DosmLawVelocityVerlet>(*dosmLawLJP, currSnap, DOSM_DT, DOSM_BOX_LENGTH);
		dosmParticleSnap.snaps[0] = currSnap;
		std::time_t t0 = std::time(nullptr);
		for (idx_t step = 1; step < DOSM_STEPS; ++step)
		{
			dosmParallel.dispatch(1, [&](idx_t) { idosmLaw->kernel(&result); });
			dosmParticleSnap.snaps.push_back(currSnap);
			dosm::ui64_t elapsed = static_cast<dosm::ui64_t>(std::time(nullptr) - t0);
			DOSM_PROGRESS("Time step", step + 1, DOSM_STEPS, elapsed);
		}
		// dosmLawLJP->kernel(&result);
		// dosmParticleSnap.snaps[0] = currSnap;
		dosmParallel.release();
		outFile();

		DOSM_LOG_INFO("Factor::run() done");
	}

} // namespace dosm
