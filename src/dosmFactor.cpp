#include "dosmFactor.hpp"
#include "dosmLawVV.hpp"
#include "dosmLawLJPNB.hpp"
#include "dosmSocketPublisher.hpp"

#include <cstdio>
#include <chrono>
#include <fstream>
#include <stdexcept>

#define DOSM_SEED        42
#define DOSM_SIGMA       3.0
#define DOSM_EPSILON     0.2
#define DOSM_BOX_LENGTH  42.0
#define DOSM_RAY_CUT     10.0
#define DOSM_SKIN        2.0
#define DOSM_MASS        18.0
#define DOSM_CHARGE      0.0
#define DOSM_DT          1.0
#define DOSM_STEPS       5000
#define DOSM_STEP_EVERY  10
#define DOSM_IP          "127.0.0.1"
#define DOSM_PORT        5555


namespace dosm
{

    DosmFactor::DosmFactor(const str_t& file)
    {
        std::srand(DOSM_SEED);
        loadFile(file);
    }

    void DosmFactor::loadFile(const str_t& file)
    {
        std::ifstream in(file);
        if (!in)
        {
            DOSM_LOG_ERROR("Cannot open file: " + file);
            throw std::runtime_error("dosmFactor: cannot open file");
        }

        in.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

        vector_t<DosmParticle> particles;
        i32_t type;
        r64_t x, y, z;
        while (in >> type >> x >> y >> z)
        {
            DosmParticle particle(DOSM_MASS, DOSM_CHARGE);
            particle.position(0) = x;
            particle.position(1) = y;
            particle.position(2) = z;
            particle.velocity(0) = particle.velocity(1) = particle.velocity(2) = 0.0;
            particles.push_back(particle);
        }

        dosmParticleSnap.snaps.clear();
        dosmParticleSnap.snaps.push_back(DosmParticleSnap::Snap{0.0, particles});
        DOSM_LOG_INFO("Loaded " + std::to_string(particles.size()) + " particles");
    }

    void DosmFactor::outFile(void)
    {
        const str_t csvFile = "dosmdata.csv";
        const str_t pdbFile = "dosmvisual.pdb";

        std::ofstream csv(csvFile);
        if (!csv)
        {
            DOSM_LOG_ERROR("Cannot open CSV file: " + csvFile);
            return;
        }

        std::ofstream pdb(pdbFile);
        if (!pdb)
        {
            DOSM_LOG_ERROR("Cannot open PDB file: " + pdbFile);
            return;
        }

        chr_t line[1024];

        snprintf(
                line,
                sizeof(line),
                "snap\tt\tid\tmass\tx\ty\tz\tpx\tpy\tpz\tfx\tfy\tfz\tEk\tEp\tT\n"
                );
        csv << line;


        snprintf(line, sizeof(line), "HEADER    DOSM PARTICLES\n");
        pdb << line;

        snprintf(line, sizeof(line), "REMARK    Generated by dosmetric\n");
        pdb << line;

        snprintf(
                line,
                sizeof(line),
                "CRYST1%9.3f%9.3f%9.3f  90.00  90.00  90.00 P 1\n",
                DOSM_BOX_LENGTH, DOSM_BOX_LENGTH, DOSM_BOX_LENGTH
                );
        pdb << line;

        const idx_t nSnap = dosmParticleSnap.snaps.size();

        for (idx_t i = 0; i < nSnap; ++i)
        {
            const auto& snap = dosmParticleSnap.snaps[i];
            const idx_t ntasks = snap.particles.size();
            const idx_t Ndl = 3 * ntasks - 3;
            constexpr r64_t CONSTANT_R = 0.00199;
            r64_t Ec = 0.0;
            for (const auto& particle : snap.particles)
                Ec += particle.k_energy;

            r64_t T = (Ndl > 0) ? (Ec / (Ndl * CONSTANT_R)) : 0.0;
            snprintf(
                    line,
                    sizeof(line),
                    "MODEL     %d\n",
                    i + 1
                    );
            pdb << line;

            const idx_t n = snap.particles.size();
            for (idx_t j = 0; j < n; ++j)
            {
                const DosmParticle& particle = snap.particles[j];

                snprintf(
                        line,
                        sizeof(line),
                        "%d\t%.17g\t%d\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\t%.17g\n",
                        i,
                        snap.t,
                        j,
                        particle.mass,
                        particle.position(0), particle.position(1), particle.position(2),
                        particle.momentum(0), particle.momentum(1), particle.momentum(2),
                        particle.force(0),    particle.force(1),    particle.force(2),
                        particle.k_energy,
                        particle.p_energy,
                        T
                        );
                csv << line;

                snprintf(
                        line,
                        sizeof(line),
                        "HETATM%5d  %-3.3s %-3.3s %4d    %8.3f%8.3f%8.3f%6.2f%6.2f           %.2s\n",
                        j + 1,
                        "X",
                        "SIM",
                        1,
                        particle.position(0), particle.position(1), particle.position(2),
                        1.00,
                        particle.p_energy,
                        "X"
                        );

                pdb << line;
            }

            snprintf(line, sizeof(line), "ENDMDL\n");
            pdb << line;

            DOSM_PROGRESS("Generating output", i + 1, nSnap, -1);
        }

        DOSM_LOG_INFO("Generated outputs: " + csvFile + ", " + pdbFile);
    }

    void DosmFactor::run(void)
    {
        DOSM_LOG_DEBUG("Factor::run() entered");

        IDosmLaw::Result result;

        DosmParticleSnap::Snap currSnap = dosmParticleSnap.snaps.back();

        for (auto& particle : currSnap.particles)
            particle.mass = DOSM_MASS;

        auto dosmLawLJ = std::make_unique<DosmLawLJ>(currSnap.particles, DOSM_SIGMA, DOSM_EPSILON);
        auto dosmLawLJP = std::make_unique<DosmLawLJP>(currSnap.particles, DOSM_SIGMA, DOSM_EPSILON, DOSM_BOX_LENGTH, DOSM_RAY_CUT);
        auto dosmLawLJPNB = std::make_unique<DosmLawLJPNB>(currSnap.particles, DOSM_SIGMA, DOSM_EPSILON, DOSM_BOX_LENGTH, DOSM_RAY_CUT, DOSM_SKIN, DOSM_STEP_EVERY);
        idosmLaw = std::make_unique<DosmLawVV>(*dosmLawLJPNB, currSnap, DOSM_DT, DOSM_BOX_LENGTH, DOSM_STEP_EVERY);

        dosmParticleSnap.snaps[0] = currSnap;
        idosmSocket = std::make_unique<DosmSocketPublisher>(DOSM_IP, (ui16_t)DOSM_PORT);
        idosmSocket->init();
        auto t0 = std::chrono::steady_clock::now();
        for (idx_t step = 1; step < DOSM_STEPS; ++step)
        {
            result.idosmSocket = idosmSocket.get();
            idosmLaw->kernel(&result);
            dosmParticleSnap.snaps.push_back(currSnap);
            ui64_t elapsed = (ui64_t)std::chrono::duration_cast<std::chrono::seconds>(std::chrono::steady_clock::now() - t0).count();
            DOSM_PROGRESS("Time step", step + 1, DOSM_STEPS, elapsed);
        }

        idosmSocket->release();

        outFile();

        DOSM_LOG_INFO("Factor::run() done");
    }

} // namespace dosm
